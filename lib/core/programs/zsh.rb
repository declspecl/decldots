# typed: strict
# frozen_string_literal: true

require_relative "base"

module Decldots
    module Programs
        # Zsh shell configuration program
        class Zsh < Base
            extend T::Sig

            sig { override.params(options: T::Hash[Symbol, T.untyped]).void }
            def configure(options)
                validate_options!(options)

                config_dir = Decldots.dry_run? ? Decldots.dry_run_directory : home_directory
                config_file = File.join(config_dir, ".zshrc")
                content = generate_shell_config(options)
                write_file(config_file, content)
                puts "Wrote config to #{config_file}"

                configure_oh_my_zsh(options[:oh_my_zsh]) if options[:oh_my_zsh]
            end

            sig { override.params(options: T::Hash[Symbol, T.untyped]).void }
            def validate_options!(options)
                raise ValidationError, "Shell aliases must be a hash" if options[:aliases] && !options[:aliases].is_a?(Hash)
                raise ValidationError, "Oh My Zsh configuration must be a hash" if options[:oh_my_zsh] && !options[:oh_my_zsh].is_a?(Hash)
            end

            sig { override.params(options: T::Hash[Symbol, T.untyped]).returns(T::Hash[Symbol, T.untyped]) }
            def diff_configuration(options)
                expected_config_file = File.join(home_directory, ".zshrc")
                expected_content = generate_shell_config(options)

                if file_matches_content?(expected_config_file, expected_content)
                    { action: :no_change, file: expected_config_file }
                else
                    { action: :update, file: expected_config_file, changes: "Zsh configuration would be updated" }
                end
            end

            private

            sig { params(options: T::Hash[Symbol, T.untyped]).returns(String) }
            def generate_shell_config(options)
                config_parts = []

                config_parts << "# Generated by Decldots - #{Time.now}"
                config_parts << ""

                config_parts.concat(generate_zsh_options(options))
                config_parts.concat(generate_environment_variables(options[:environment_variables])) if options[:environment_variables]
                config_parts.concat(generate_aliases(options[:aliases])) if options[:aliases]
                config_parts.concat(generate_oh_my_zsh_config(options[:oh_my_zsh])) if options[:oh_my_zsh]
                config_parts.concat(generate_zsh_features(options))

                if options[:shell_init]
                    config_parts << ""
                    config_parts << "# Custom initialization"
                    config_parts << options[:shell_init]
                end

                config_parts.join("\n")
            end

            sig { params(options: T::Hash[Symbol, T.untyped]).returns(T::Array[String]) }
            def generate_zsh_options(options)
                lines = []

                lines << "# Zsh options"
                lines << "setopt AUTO_CD"
                lines << "setopt CORRECT"
                lines << "setopt HIST_VERIFY"

                if options[:enable_completion]
                    lines << ""
                    lines << "# Enable completion"
                    lines << "autoload -Uz compinit"
                    lines << "compinit"
                end

                if options[:enable_autosuggestion]
                    lines << ""
                    lines << "# Enable autosuggestions (requires zsh-autosuggestions plugin)"
                    lines << "source $(brew --prefix)/share/zsh-autosuggestions/zsh-autosuggestions.zsh 2>/dev/null || true"
                end

                if options[:enable_syntax_highlighting]
                    lines << ""
                    lines << "# Enable syntax highlighting (requires zsh-syntax-highlighting plugin)"
                    lines << "source $(brew --prefix)/share/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh 2>/dev/null || true"
                end

                lines << ""
                lines
            end

            sig { params(env_vars: T.nilable(T::Hash[T.untyped, T.untyped])).returns(T::Array[String]) }
            def generate_environment_variables(env_vars)
                return [] unless env_vars&.any?

                lines = ["# Environment variables"]
                env_vars.each do |key, value|
                    lines << "export #{key}=\"#{value}\""
                end
                lines << ""
                lines
            end

            sig { params(aliases: T.nilable(T::Hash[T.untyped, T.untyped])).returns(T::Array[String]) }
            def generate_aliases(aliases)
                return [] unless aliases&.any?

                lines = ["# Aliases"]
                aliases.each do |name, command|
                    lines << "alias #{name}=\"#{command}\""
                end
                lines << ""
                lines
            end

            sig { params(omz_config: T::Hash[Symbol, T.untyped]).returns(T::Array[String]) }
            def generate_oh_my_zsh_config(omz_config)
                return [] unless omz_config[:enable]

                lines = ["# Oh My Zsh configuration"]

                lines << "export ZSH=\"$HOME/.oh-my-zsh\""

                theme = omz_config[:theme] || "robbyrussell"
                lines << "ZSH_THEME=\"#{theme}\""

                if omz_config[:plugins]&.any?
                    plugins_list = omz_config[:plugins].join(" ")
                    lines << "plugins=(#{plugins_list})"
                end

                if omz_config[:extra_config]
                    lines << ""
                    lines << omz_config[:extra_config]
                end

                lines << ""
                lines << "source $ZSH/oh-my-zsh.sh"
                lines << ""

                lines
            end

            sig { params(_options: T::Hash[Symbol, T.untyped]).returns(T::Array[String]) }
            def generate_zsh_features(_options)
                lines = []

                lines << "# Zsh-specific features"
                lines << "HISTSIZE=10000"
                lines << "SAVEHIST=10000"
                lines << "HISTFILE=~/.zsh_history"
                lines << "setopt SHARE_HISTORY"
                lines << "setopt HIST_IGNORE_DUPS"

                lines << ""
                lines
            end

            sig { params(omz_config: T::Hash[Symbol, T.untyped]).void }
            def configure_oh_my_zsh(omz_config)
                return unless omz_config[:enable]

                omz_dir = File.join(home_directory, ".oh-my-zsh")
                return if Dir.exist?(omz_dir)

                puts "Installing Oh My Zsh..."
                install_command = 'sh -c "$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)" "" --unattended'
                system(install_command)
            end
        end
    end
end
