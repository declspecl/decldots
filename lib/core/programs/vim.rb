# typed: strict
# frozen_string_literal: true

require_relative "base"

module Decldots
    module Programs
        # Vim configuration program
        class Vim < Base
            extend T::Sig

            sig { override.params(options: T::Hash[Symbol, T.untyped]).void }
            def configure(options)
                validate_options!(options)

                config_dir = Decldots.dry_run? ? Decldots.dry_run_directory : home_directory
                config_file = File.join(config_dir, ".vimrc")

                content = generate_vim_config(options)
                write_file(config_file, content)
                puts "Wrote Vim configuration to #{config_file}"
            end

            sig { override.params(options: T::Hash[Symbol, T.untyped]).void }
            def validate_options!(options)
                if options[:tab_width] && (!options[:tab_width].is_a?(Integer) || options[:tab_width] <= 0)
                    raise ValidationError, "Tab width must be a positive integer"
                end

                raise ValidationError, "Color scheme must be a string" if options[:color_scheme] && !options[:color_scheme].is_a?(String)

                return unless options[:key_mappings] && !options[:key_mappings].is_a?(Hash)

                raise ValidationError, "Key mappings must be a hash"
                
            end

            sig { override.params(options: T::Hash[Symbol, T.untyped]).returns(T::Hash[Symbol, T.untyped]) }
            def diff_configuration(options)
                expected_config_file = File.join(home_directory, ".vimrc")
                expected_content = generate_vim_config(options)

                if file_matches_content?(expected_config_file, expected_content)
                    { action: :no_change, file: expected_config_file }
                else
                    { action: :update, file: expected_config_file, changes: "Vim configuration would be updated" }
                end
            end

            private

            sig { params(options: T::Hash[Symbol, T.untyped]).returns(String) }
            def generate_vim_config(options)
                config_lines = []

                config_lines << "\" Generated by Decldots - #{Time.now}"
                config_lines << ""

                config_lines.concat(generate_basic_settings(options))
                config_lines.concat(generate_appearance_settings(options))
                config_lines.concat(generate_key_mappings(options))

                config_lines.join("\n")
            end

            sig { params(options: T::Hash[Symbol, T.untyped]).returns(T::Array[String]) }
            def generate_basic_settings(options)
                lines = []
                lines << "set expandtab" if options[:expand_tabs]
                lines << "set mouse=a" if options[:mouse]
                lines << "syntax on" if options[:syntax_highlighting]
                lines << "set number" if options[:line_numbers]

                if options[:tab_width]
                    lines << "set tabstop=#{options[:tab_width]}"
                    lines << "set shiftwidth=#{options[:tab_width]}"
                end

                lines << "" if lines.any?
                lines
            end

            sig { params(options: T::Hash[Symbol, T.untyped]).returns(T::Array[String]) }
            def generate_appearance_settings(options)
                lines = []
                lines << "colorscheme #{options[:color_scheme]}" if options[:color_scheme]
                lines << "" if lines.any?
                lines
            end

            sig { params(options: T::Hash[Symbol, T.untyped]).returns(T::Array[String]) }
            def generate_key_mappings(options)
                lines = []

                if options[:key_mappings] && options[:key_mappings].any?
                    lines << "\" Key mappings"
                    options[:key_mappings].each do |key, command|
                        lines << "nnoremap #{key} #{command}"
                    end
                    lines << ""
                end

                lines
            end
        end
    end
end
