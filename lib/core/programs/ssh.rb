# typed: strict
# frozen_string_literal: true

require_relative "base"

module Decldots
    module Programs
        # SSH configuration program
        class Ssh < Base
            extend T::Sig

            sig { override.params(options: T::Hash[Symbol, T.untyped]).void }
            def configure(options)
                validate_options!(options)

                config_dir = Decldots.dry_run? ? Decldots.dry_run_directory : home_directory
                ssh_dir = File.join(config_dir, ".ssh")
                config_file = File.join(ssh_dir, "config")

                ensure_directory_exists(ssh_dir)
                set_ssh_directory_permissions(ssh_dir) unless Decldots.dry_run?

                content = generate_ssh_config(options)
                write_file(config_file, content)
                set_ssh_config_permissions(config_file) unless Decldots.dry_run?
                
                puts "Wrote SSH configuration to #{config_file}"
            end

            sig { override.params(options: T::Hash[Symbol, T.untyped]).void }
            def validate_options!(options)
                if options[:connect_timeout] && (!options[:connect_timeout].is_a?(Integer) || options[:connect_timeout] <= 0)
                    raise ValidationError, "Connect timeout must be a positive integer"
                end

                if options[:server_alive_interval] && (!options[:server_alive_interval].is_a?(Integer) || options[:server_alive_interval] <= 0)
                    raise ValidationError, "Server alive interval must be a positive integer"
                end

                return unless options[:hosts] && !options[:hosts].is_a?(Hash)

                raise ValidationError, "Hosts must be a hash"
            end

            sig { override.params(options: T::Hash[Symbol, T.untyped]).returns(T::Hash[Symbol, T.untyped]) }
            def diff_configuration(options)
                expected_config_file = File.join(home_directory, ".ssh", "config")
                expected_content = generate_ssh_config(options)

                if file_matches_content?(expected_config_file, expected_content)
                    { action: :no_change, file: expected_config_file }
                else
                    { action: :update, file: expected_config_file, changes: "SSH configuration would be updated" }
                end
            end

            private

            sig { params(options: T::Hash[Symbol, T.untyped]).returns(String) }
            def generate_ssh_config(options)
                config_lines = []

                config_lines << "# Generated by Decldots - #{Time.now}"
                config_lines << ""

                config_lines.concat(generate_global_settings(options))
                config_lines.concat(generate_host_configurations(options))

                config_lines.join("\n")
            end

            sig { params(options: T::Hash[Symbol, T.untyped]).returns(T::Array[String]) }
            def generate_global_settings(options)
                lines = []

                lines << "Host *"
                lines << "    Compression yes" if options[:compression]
                lines << "    ConnectTimeout #{options[:connect_timeout]}" if options[:connect_timeout]
                lines << "    ServerAliveInterval #{options[:server_alive_interval]}" if options[:server_alive_interval]
                lines << "    ServerAliveCountMax #{options[:server_alive_count_max]}" if options[:server_alive_count_max]
                lines << "    ForwardAgent yes" if options[:forward_agent]
                lines << "    ForwardX11 yes" if options[:forward_x11]

                lines << "" if lines.length > 1
                lines
            end

            sig { params(options: T::Hash[Symbol, T.untyped]).returns(T::Array[String]) }
            def generate_host_configurations(options)
                lines = []
                return lines unless options[:hosts]

                options[:hosts].each do |hostname, config|
                    lines << "Host #{hostname}"

                    config.each do |key, value|
                        ssh_key = key.to_s.split(/(?=[A-Z])/).map(&:downcase).join("_")
                        ssh_key = ssh_key.split("_").map(&:capitalize).join("")
                        
                        lines << "    #{ssh_key} #{value}"
                    end

                    lines << ""
                end

                lines
            end

            sig { params(ssh_dir: String).void }
            def set_ssh_directory_permissions(ssh_dir)
                File.chmod(0o700, ssh_dir)
            end

            sig { params(config_file: String).void }
            def set_ssh_config_permissions(config_file)
                File.chmod(0o600, config_file)
            end
        end
    end
end
