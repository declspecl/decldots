# typed: strict
# frozen_string_literal: true

require_relative "base"

module Rbdots
    module Programs
        # Shell configuration program for zsh and bash.
        class Shell < Base
            extend T::Sig

            sig { override.params(options: T::Hash[Symbol, T.untyped]).void }
            def configure(options)
                validate_options(options)

                shell_type = detect_shell_type(options)
                config_file = shell_config_file(shell_type)

                content = generate_shell_config(options, shell_type)
                write_file(config_file, content)

                configure_oh_my_zsh(options[:oh_my_zsh]) if options[:oh_my_zsh] && shell_type == :zsh
            end

            sig { override.params(options: T::Hash[Symbol, T.untyped]).returns(T::Boolean) }
            def validate_options(options)
                if options[:aliases] && !options[:aliases].is_a?(Hash)
                    raise ValidationError, 
                          "Shell aliases must be a hash"
                end

                true
            end

            sig { override.params(options: T::Hash[Symbol, T.untyped]).returns(T::Hash[Symbol, T.untyped]) }
            def diff_configuration(options)
                shell_type = detect_shell_type(options)
                config_file = shell_config_file(shell_type)
                expected_content = generate_shell_config(options, shell_type)

                if file_matches_content?(config_file, expected_content)
                    { action: :no_change, file: config_file }
                else
                    { action: :update, file: config_file, changes: "Shell configuration would be updated" }
                end
            end

            private

            sig { params(options: T::Hash[Symbol, T.untyped]).returns(Symbol) }
            def detect_shell_type(options)
                # Could be made more sophisticated based on system shell or explicit option
                options[:shell_type]&.to_sym || :zsh
            end

            sig { params(shell_type: Symbol).returns(String) }
            def shell_config_file(shell_type)
                case shell_type
                when :zsh
                    File.join(home_directory, ".zshrc")
                when :bash
                    File.join(home_directory, ".bashrc")
                else
                    raise ConfigurationError, "Unsupported shell type: #{shell_type}"
                end
            end

            sig do
                params(
                    options: T::Hash[Symbol, T.untyped],
                    shell_type: Symbol
                ).returns(String)
            end
            def generate_shell_config(options, shell_type)
                config_parts = []

                config_parts << "# Generated by Rbdots - #{Time.now}"
                config_parts << ""

                config_parts.concat(generate_shell_options(options, shell_type))

                if options[:environment_variables]
                    config_parts.concat(generate_environment_variables(options[:environment_variables]))
                end

                config_parts.concat(generate_aliases(options[:aliases])) if options[:aliases]

                if shell_type == :zsh && options[:oh_my_zsh]
                    config_parts.concat(generate_oh_my_zsh_config(options[:oh_my_zsh]))
                end

                config_parts.concat(generate_shell_features(options, shell_type))

                if options[:shell_init]
                    config_parts << ""
                    config_parts << "# Custom initialization"
                    config_parts << options[:shell_init]
                end

                config_parts.join("\n")
            end

            sig do
                params(
                    options: T::Hash[Symbol, T.untyped],
                    shell_type: Symbol
                ).returns(T::Array[String])
            end
            def generate_shell_options(options, shell_type)
                lines = []

                if shell_type == :zsh
                    lines << "# Zsh options"
                    lines << "setopt AUTO_CD" # Enable auto cd
                    lines << "setopt CORRECT" # Enable command correction
                    lines << "setopt HIST_VERIFY" # Show command before executing from history

                    if options[:enable_completion]
                        lines << ""
                        lines << "# Enable completion"
                        lines << "autoload -Uz compinit"
                        lines << "compinit"
                    end

                    if options[:enable_autosuggestion]
                        lines << ""
                        lines << "# Enable autosuggestions (requires zsh-autosuggestions plugin)"
                        lines << "# Install with: brew install zsh-autosuggestions"
                        lines << "source $(brew --prefix)/share/zsh-autosuggestions/zsh-autosuggestions.zsh 2>/dev/null || true"
                    end

                    if options[:enable_syntax_highlighting]
                        lines << ""
                        lines << "# Enable syntax highlighting (requires zsh-syntax-highlighting plugin)"
                        lines << "# Install with: brew install zsh-syntax-highlighting"
                        lines << "source $(brew --prefix)/share/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh 2>/dev/null || true"
                    end
                elsif shell_type == :bash
                    lines << "# Bash options"
                    lines << "set -o vi" # Enable vi mode

                    if options[:enable_completion]
                        lines << ""
                        lines << "# Enable bash completion"
                        lines << "[ -r /usr/local/etc/profile.d/bash_completion.sh ] && . /usr/local/etc/profile.d/bash_completion.sh"
                    end
                end

                lines << ""
                lines
            end

            sig { params(env_vars: T.nilable(T::Hash[T.untyped, T.untyped])).returns(T::Array[String]) }
            def generate_environment_variables(env_vars)
                return [] unless env_vars&.any?

                lines = ["# Environment variables"]
                env_vars.each do |key, value|
                    lines << "export #{key}=\"#{value}\""
                end
                lines << ""
                lines
            end

            sig { params(aliases: T.nilable(T::Hash[T.untyped, T.untyped])).returns(T::Array[String]) }
            def generate_aliases(aliases)
                return [] unless aliases&.any?

                lines = ["# Aliases"]
                aliases.each do |name, command|
                    lines << "alias #{name}=\"#{command}\""
                end
                lines << ""
                lines
            end

            sig { params(omz_config: T::Hash[Symbol, T.untyped]).returns(T::Array[String]) }
            def generate_oh_my_zsh_config(omz_config)
                return [] unless omz_config[:enable]

                lines = ["# Oh My Zsh configuration"]

                lines << "export ZSH=\"$HOME/.oh-my-zsh\""

                theme = omz_config[:theme] || "robbyrussell"
                lines << "ZSH_THEME=\"#{theme}\""

                if omz_config[:plugins]&.any?
                    plugins_list = omz_config[:plugins].join(" ")
                    lines << "plugins=(#{plugins_list})"
                end

                if omz_config[:extra_config]
                    lines << ""
                    lines << omz_config[:extra_config]
                end

                lines << ""
                lines << "source $ZSH/oh-my-zsh.sh"
                lines << ""

                lines
            end

            sig do
                params(
                    _options: T.untyped,
                    shell_type: Symbol
                ).returns(T::Array[String])
            end
            def generate_shell_features(_options, shell_type)
                lines = []

                if shell_type == :zsh
                    lines << "# Zsh-specific features"
                    lines << "HISTSIZE=10000"
                    lines << "SAVEHIST=10000"
                    lines << "HISTFILE=~/.zsh_history"
                    lines << "setopt SHARE_HISTORY"
                    lines << "setopt HIST_IGNORE_DUPS"
                elsif shell_type == :bash
                    lines << "# Bash-specific features"
                    lines << "HISTSIZE=10000"
                    lines << "HISTFILESIZE=20000"
                    lines << "shopt -s histappend"
                end

                lines << ""
                lines
            end

            sig { params(omz_config: T::Hash[Symbol, T.untyped]).void }
            def configure_oh_my_zsh(omz_config)
                return unless omz_config[:enable]

                omz_dir = File.join(home_directory, ".oh-my-zsh")

                return if Dir.exist?(omz_dir)

                puts "Installing Oh My Zsh..."
                install_command = 'sh -c "$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)" "" --unattended'
                system(install_command)
            end
        end
    end
end
